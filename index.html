<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="We are all live in the gutter, but some of us are looking at the star">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Alex&#39;s Blog">
<meta property="og:description" content="We are all live in the gutter, but some of us are looking at the star">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex&#39;s Blog">
<meta name="twitter:description" content="We are all live in the gutter, but some of us are looking at the star">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Alex's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/03/数学建模方法与分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/03/数学建模方法与分析/" itemprop="url">数学建模方法与分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T20:21:04+08:00">
                2018-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在英语课上看完了一部分关于数学建模方法的书，这里写一个大概几百字的总结。</p>
</blockquote>
<h1 id="数学建模方法与分析——最优化模型"><a href="#数学建模方法与分析——最优化模型" class="headerlink" title="数学建模方法与分析——最优化模型"></a>数学建模方法与分析——最优化模型</h1><p>在数学建模里有一类题是最优解，如进行工作希望达到最好的效果，企业试图通过对一些变量的控制从而达到利益的最大化，或者达到某一预期目标的前提下使得成本最低，等等等等。这些问题或许有些在高中初中已经做过，这里便是对求这样题的的基本思路，介绍一下数学建模的基础知识。</p>
<h2 id="单变量最优化"><a href="#单变量最优化" class="headerlink" title="单变量最优化"></a>单变量最优化</h2><h3 id="五步方法"><a href="#五步方法" class="headerlink" title="五步方法"></a>五步方法</h3><p>在数学建模的时候，我们解决问题的一般过程，我们称之为五步方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 提出问题</span><br><span class="line">2. 选择建模方法</span><br><span class="line">3. 推导模型的数学表达式</span><br><span class="line">4. 求解模型</span><br><span class="line">5. 回答问题</span><br></pre></td></tr></table></figure>
<h4 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h4><p>第一步是提出问题，这里的提出问题并不是把我们得到的数学建模题目抄下来一遍就完事的问题。而是要对我们的实际问题用数学语言表达出来，并且对实际问题作出一些假设，在这个阶段，我们不必担心需要作出推测，因为我们往往总是可以在后面的过程中随时做出更好的推测。当然在用数学术语提出问题前，我们需要尽可能的把需要用到的，那些术语作出定义。</p>
<p>首先列出实际问题设计的变量，同时选择其合适的单位。然后，写出关于这个变量有关的假设， 列出我们已知的或者假设的等式或者不等式，这些做完了，我们也可以正式的提出问题了。</p>
<blockquote>
<p>为了方便理解，我们引入一个简单的例子：一头猪重100kg，每天增重2.5kg，每天喂猪需要花费0.45元，猪的价格是每kg0.65元，但是价格每天下降一分，求出我们利润最高的出售时间。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//最好在这里列出一个表格，简单清晰明了</span><br><span class="line">//为了避免混淆，这里采用大小写区分模式</span><br><span class="line">涉及到的变量：</span><br><span class="line">			t，时间（天）</span><br><span class="line">			w，猪的重量（kg）</span><br><span class="line">			p，猪的价格（元）</span><br><span class="line">			C，喂猪的花费（元）</span><br><span class="line">			R，卖猪的收益（元）</span><br><span class="line">			P，净收益（元）</span><br><span class="line">假设满足的条件：</span><br><span class="line">			w = 200 + 5t</span><br><span class="line">			p = 0.65 - 0.01</span><br><span class="line">			C = 0.45t</span><br><span class="line">			R = p * w</span><br><span class="line">			P = R - C</span><br><span class="line">			t &gt;= 0</span><br><span class="line">所需要求的目标：</span><br><span class="line">			P的最大值</span><br></pre></td></tr></table></figure>
<p>当这样列出来之后，需要做的也是比较简单明了，队友进行深度思考的时候也会很容易的和你的思维进行接轨。</p>
<h4 id="选择建模方法"><a href="#选择建模方法" class="headerlink" title="选择建模方法"></a>选择建模方法</h4><p>当我们完成第一步的时候，我们已经有了一个用数学语言描述的问题了，我们需要选择一种数学方法来获得解。许多问题都可以表示成一个已有有效的一般求解方法的标准形式。建模方法在本文里不做详细的介绍，需要大家多多查询数学与应用数学相关的论文，或者参考一下大学高等数学教科书，或者微积分入门教科书。</p>
<h4 id="推导模型的数学表达式"><a href="#推导模型的数学表达式" class="headerlink" title="推导模型的数学表达式"></a>推导模型的数学表达式</h4><p>在这里就类似于方程的求解问题，我们把第一步得到的问题应用于第二步，进行部分化简写出较简洁的答案。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如我们的例题：</span><br><span class="line">	P = R - C</span><br><span class="line">	  = p*w - o.45t	</span><br><span class="line">      = (0.65 - 0.01t)*(200 + 5t) - 0.45t</span><br></pre></td></tr></table></figure>
<h4 id="求解模型"><a href="#求解模型" class="headerlink" title="求解模型"></a>求解模型</h4><p>在这一步是我们组的队长给我分配的任务。是在matlab里对第三步推导出来的数学公式用程序语言实现并尽可能的用更为形象的图像来展示出来，标出几个比较关键的点来支撑起整个模型。</p>
<h4 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h4><p>最后一步，回答我们在第一步中提出的问题：何时我们才会有最高利润？由我们的数学模型，我们可以得到某种结论，在这里，如果我们的假设是对的，那么我们的结果就是对的，相关的问题及不同的假设可以按照第一步中的做法调整得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//对于五步方法的总结</span><br><span class="line"></span><br><span class="line">第一步————提出问题：</span><br><span class="line">				1. 列出问题中设计的变量，包括适当的单位。</span><br><span class="line">				2. 注意不要混淆变量和常量。</span><br><span class="line">				3. 列出你对变量所做的全部假设，包括等式和不等式。</span><br><span class="line">				4. 检查单位从而保证你的假设有意义。</span><br><span class="line">				5. 用准确的数学术语给出问题的目标</span><br><span class="line">第二步————选择建模方法：</span><br><span class="line">				1. 选择解决问题的一个一般求解方法</span><br><span class="line">				2. 一般的，这一步的陈工需要经验，技巧和熟悉相关的论文</span><br><span class="line">第三步————推到模型中的数学表达式：</span><br><span class="line">				1. 将第一步中得到的问题重新表达成第二步选定的建模方法所需要的形式。</span><br><span class="line">				2. 记下任何补充假设，这些假设是为了使得第一步中描述的问题与第二步中选定的数学结构相适应					而作出的。</span><br><span class="line">第四步————求解模型：</span><br><span class="line">				1. 将第二部所选的一般求解过程应用于第三部得到表达式的特定问题</span><br><span class="line">				2. 注意数学推导，检查是否有错误，答案是否有意义</span><br><span class="line">				3. 可以采用matlab或者maple等进行形象化的实现</span><br><span class="line">第五步————回答问题：</span><br><span class="line">				1. 用非技术性的语言将第四步的结果重新表述</span><br><span class="line">				2. 避免数学符号和术语</span><br><span class="line">				3. 能理解最初提出的问题就可以理解给出的答案</span><br></pre></td></tr></table></figure>
<p>数学建模比赛用到的方法好像真的只有五步法，作者本人数学建模的参赛经验并不是很多，这里暂时先写到这里，对于以后的深刻讨论，下一篇文章会写。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/27/关于网络流的算法问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/关于网络流的算法问题/" itemprop="url">关于网络流的算法问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T19:51:34+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>引言：图论里个人感觉比较难的算法，emm……辜负了学长的期望，到现在为止还是一脸懵逼。</p>
<p>问题描述：为了比较形象的描述问题，我们还是直接进入正题。</p>
</blockquote>
<p>在开始正题之前，我们要先明白一下最大流的含义：从源点经过所有路径最终到达汇点所有流量之和。</p>
<h1 id="关于网络流的算法问题"><a href="#关于网络流的算法问题" class="headerlink" title="关于网络流的算法问题"></a>关于网络流的算法问题</h1><h2 id="EK算法"><a href="#EK算法" class="headerlink" title="EK算法"></a>EK算法</h2><h3 id="EK算法的核心"><a href="#EK算法的核心" class="headerlink" title="EK算法的核心"></a>EK算法的核心</h3><p>反复寻找源点到汇点之间的增广路径，若有，则找出增广路径上每一段[容量]-[流量]的最小值delta，若无，则结束。在寻找增广路径时，我们可以用BFS来寻找并更新残留网络的值（这里有一个关于反向边的问题），在找到一个delta后，则使最大流加上一个delta，更新当前的最大流的值。</p>
<h3 id="网络流的基本知识点"><a href="#网络流的基本知识点" class="headerlink" title="网络流的基本知识点"></a>网络流的基本知识点</h3><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fprnbxqzo6j30cm09gt9h.jpg" alt="img"></p>
<p>如图，这是一个有向图，离散虽然没学多好，但是有向图还是晓得的～</p>
<h4 id="源点"><a href="#源点" class="headerlink" title="源点"></a>源点</h4><p>源点又称点源。单位厚度含水层中半径为无限小的注水点。（形象点来说的话就是我们的水龙头）</p>
<h4 id="汇点"><a href="#汇点" class="headerlink" title="汇点"></a>汇点</h4><p>汇点又称点汇。单位厚度含水层中半径为无限小的抽水点。（形象点来说的话就是我们洗脸盆下面的那个通下水道的地方，我也不知道叫啥～～）</p>
<h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><p>比较抽象，形象点来说就是我们的注水管道。（在这里我们需要注意的一点是这里的边都是有向——单向的，所以我们假设不存在反向注水的可能）。</p>
<h4 id="容量和流量"><a href="#容量和流量" class="headerlink" title="容量和流量"></a>容量和流量</h4><p>在上面的有向图里，我们可以看到在边上有一些数字，这里就是这条边的容量。（相当于我们一条注水管道最多能容纳水的体积），流量则表示当前我们在这条管道上输水的多少（可以等于容量，也可以小于容量）。</p>
<h3 id="EK算法的代码"><a href="#EK算法的代码" class="headerlink" title="EK算法的代码"></a>EK算法的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;queue&gt;</span><br><span class="line"># include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn = 1005;</span><br><span class="line">int maxData = 0x7fffffff;;</span><br><span class="line">int capacity[maxn][maxn];</span><br><span class="line">int flow[maxn];  </span><br><span class="line">int pre[maxn];</span><br><span class="line">int n, m;</span><br><span class="line">queue &lt;int&gt; myqueue;</span><br><span class="line"></span><br><span class="line">int BFS(int src, int des)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    while(!myqueue.empty())</span><br><span class="line">    	myqueue.pop();</span><br><span class="line">    memset(pre, -1, sizeof(pre));</span><br><span class="line">    pre[src] = 0;</span><br><span class="line">    flow[src] = maxData;</span><br><span class="line">    myqueue.push(src);</span><br><span class="line">    while(!myqueue.empty())&#123;</span><br><span class="line">        int index = myqueue.front();</span><br><span class="line">        myqueue.pop();</span><br><span class="line">        if(index == des)</span><br><span class="line">        	break;</span><br><span class="line">        	for(i =1; i&lt; m+!; i++)</span><br><span class="line">        		if(i != src &amp;&amp; capacity[index][i] &gt; 0 &amp;&amp; pre[i] ==-1)&#123;</span><br><span class="line">                    pre[i] = index;</span><br><span class="line">                    flow[i] = min(capacity[index][i], flow[index]);</span><br><span class="line">                    myqueue.push(i);</span><br><span class="line">        		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (pre[des] == -1)</span><br><span class="line">    	return -1;</span><br><span class="line">    else </span><br><span class="line">    	return flow[des];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int maxFlow(int src, int des)&#123;</span><br><span class="line">    int increasement = 0;</span><br><span class="line">    int sumflow = 0;</span><br><span class="line">    while ((increasement = BFS(src, des)) != -1)&#123;</span><br><span class="line">        int k = des;</span><br><span class="line">        while(k != src)&#123;</span><br><span class="line">        	int last = pre[k];</span><br><span class="line">        	capacity[last][k] -= increasement;</span><br><span class="line">        	capacity[k][last] += increasement;</span><br><span class="line">        	k = last;</span><br><span class="line">    	&#125;</span><br><span class="line">    	sumflow += increasement;</span><br><span class="line">	&#125;</span><br><span class="line">	return sumflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	int i, j;</span><br><span class="line">	int start, end, ci;</span><br><span class="line">	while(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        memset(capacity, 0, sizeof(capacity));</span><br><span class="line">        memset(flow, 0, sizeof(flow));</span><br><span class="line">        for(i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; start &gt;&gt; end &gt;&gt; ci;</span><br><span class="line">            if(start == end)</span><br><span class="line">            	continue;</span><br><span class="line">            capacity[start][end] += ci;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; maxFlow(1, m) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emm。。。。时间过的好快，我先写一会日语作业，日语系的学生这一点真的好心累～～～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/25/标准库函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/25/标准库函数/" itemprop="url">标准库函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-25T13:57:40+08:00">
                2018-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="标准库函数（一）"><a href="#标准库函数（一）" class="headerlink" title="标准库函数（一）"></a>标准库函数（一）</h1><blockquote>
<p>引言：大一上学期学习C语言的时候，只是学习了些部分的语法，对于一些特性，还不是很熟悉，这里介绍一些标准库函数，供自己以后查阅。</p>
</blockquote>
<h2 id="Exit"><a href="#Exit" class="headerlink" title="_Exit"></a>_Exit</h2><p>正常的终止一个程序，但是不屌用之前使用atexit()或at_quick_exit()所装载的任何清理函数，也不屌用之前使用signal()所装载的任何信号处理器。_Exit()函数会返回一个状态值给操作系统，这与函数exit一样。<img src="http://img.my.csdn.net/uploads/201303/05/1362494099_4563.png" alt="            img"></p>
<p>相关函数：abort(), exit(), atexit(), quick_exit(), at_quick_exit(), raise()。</p>
<h2 id="abort"><a href="#abort" class="headerlink" title="abort"></a>abort</h2><p>abort函数通过发出一个SIGABRT信号终止程序的执行。在执行时，不会清空一打开文件的缓冲区，也不会调用之前使用atexit()或at_quick_exit()所装载的任何清理函数。</p>
<h2 id="abs"><a href="#abs" class="headerlink" title="abs"></a>abs</h2><p>获得一个整数的绝对值，在#include &lt;stdlib.h&gt;里。</p>
<h2 id="acos"><a href="#acos" class="headerlink" title="acos"></a>acos</h2><p>计算一个数值的反余弦值，在# include &lt;math.h&gt;里，acos全称叫arc cosine。</p>
<p>相关函数： </p>
<p>​    针对复数的反余弦函数：cacos(), cacosf()和cacosl()。</p>
<h2 id="acosh"><a href="#acosh" class="headerlink" title="acosh"></a>acosh</h2><p>计算一个数值的反双曲余弦， 返回一个非负值，其双曲余弦的值等于参数。由于任何数值的双曲余弦值一定大于或等于1，所以如果acosh()的参数小于1， 就会生成值域错误。</p>
<h2 id="asctime"><a href="#asctime" class="headerlink" title="asctime"></a>asctime</h2><p>把日期和时间结构转换为字符串形式。</p>
<p>asctime()的唯一参数是指向类型为struct tm结构的指针。</p>
<h2 id="asctime-s"><a href="#asctime-s" class="headerlink" title="asctime_s"></a>asctime_s</h2><p>同上，但要进行边界检查</p>
<p>暂且先看到这里吧，这本书看起来真的是头疼。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/24/MATLAB在数学建模中的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/24/MATLAB在数学建模中的应用/" itemprop="url">MATLAB在数学建模中的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-24T23:05:27+08:00">
                2018-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MATLAB/" itemprop="url" rel="index">
                    <span itemprop="name">MATLAB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>问题来源：干啃书的时候遇到了好多关于matlab的语法和内嵌函数的问题，导致好多代码看不懂，这里开一篇文章记录一下遇到的语法问题。</p>
</blockquote>
<h1 id="MATLAB中的语法问题"><a href="#MATLAB中的语法问题" class="headerlink" title="MATLAB中的语法问题"></a>MATLAB中的语法问题</h1><p>记录时间2018.3.24，好像并没有记录下什么，明天在更新吧，耳机没电，听不到音频没办法总结，今天暂且这样，早睡一天，明天还要培训呢！晚安！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/23/BlockChain周结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/23/BlockChain周结/" itemprop="url">BlockChain周结————区块链记账原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T15:41:15+08:00">
                2018-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BlockChain/" itemprop="url" rel="index">
                    <span itemprop="name">BlockChain</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BlockChain周结————区块链记账原理"><a href="#BlockChain周结————区块链记账原理" class="headerlink" title="BlockChain周结————区块链记账原理"></a>BlockChain周结————区块链记账原理</h1><blockquote>
<p>区块链作为当今热门的一个技术，开拓了数字货币的2.0时代，这里，我们开始总结一下区块链的记账原理</p>
</blockquote>
<p>区块链是一个基于密码学安全的分布式账本，是一个方便验证，不可篡改的行本，在讲区块链记账之前，我们先说明一下哈希函数。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h3 id="哈希函数的基本概念"><a href="#哈希函数的基本概念" class="headerlink" title="哈希函数的基本概念"></a>哈希函数的基本概念</h3><ol>
<li>哈希函数又称散列函数，他是单向密码体制，即从明文到密文的不可逆映射，只有加密过程而没有解密过程，哈希函数可以将任意长度的输入经过变化后得到固定长度的输出，这个固定长度的输出，称为原消息的散列或消息映射。</li>
<li>理想的哈希函数可以针对不同的输入得到不同的输出，如果存在两个不同的消息得到了相同的哈希值，那我们称这是一个碰撞</li>
</ol>
<h3 id="哈希函数的性质"><a href="#哈希函数的性质" class="headerlink" title="哈希函数的性质"></a>哈希函数的性质</h3><ol>
<li><p>可压缩性：对于任意大小的输入x，哈希值的长度很小，并且是固定的长度。</p>
</li>
<li><p>单向性： 单向性也就死通过给定的哈希值得到原文是不行的，求接哈希函数的逆很困难。</p>
</li>
<li><p>抗碰撞性： 理想的哈希函数式无碰撞的，但是实际的算法设计中很难做到，有两种抗碰撞属性。分别是：</p>
<p>a. 弱抗碰撞行：对于给定的一个消息，要发现另一个消息使其碰撞在计算上不可行。</p>
<p>b. 强抗碰撞性质，对于任意的一对不同的消息，使其碰撞在计算上不可行</p>
</li>
<li><p>高灵敏度： 当一个输入位发生变化时，会有一半以上的输出位发生变化</p>
</li>
</ol>
<h3 id="哈希函数的应用"><a href="#哈希函数的应用" class="headerlink" title="哈希函数的应用"></a>哈希函数的应用</h3><ol>
<li>消息认证： 在一个开放的网络中，需要提供一个用来验证消息完整性的服务和机制， 即消息认证， 这种服务的主要功能时确保收到的消息确实与发送的消息的来源都是真实有效的。</li>
<li>数字签名： 因为非对阵加密算法速度较慢，所以在消息摘要上进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。</li>
<li>口令的安全性：仅将口令的哈希值进行保存，进行口令娇艳的时候仅需比对哈希值即可，及时攻击者获取了口令的哈希值，也无法计算出口令</li>
<li>数据完整性： 比较熟悉的校验算法有奇偶校验和循环冗余校验码（CRC），这两种方式并没有抗数据篡改的能力他们在一定程度上能检测并纠正数据传输中的信道误码，但不能放置对数据的破坏。</li>
</ol>
<hr>
<h2 id="区块链的记账原理"><a href="#区块链的记账原理" class="headerlink" title="区块链的记账原理"></a>区块链的记账原理</h2><p>假设有一个账页序号为0的账页交易记录如下:</p>
<table>
<thead>
<tr>
<th>账号</th>
<th>入账</th>
<th>出账</th>
<th>余额</th>
<th>备注说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>王二</td>
<td>100</td>
<td></td>
<td>190</td>
<td>收到xxx货款</td>
</tr>
<tr>
<td>张三</td>
<td></td>
<td>100</td>
<td>30</td>
<td>xxxx</td>
</tr>
<tr>
<td>李四</td>
<td>120</td>
<td>90</td>
<td>170</td>
<td>xxxx</td>
</tr>
</tbody>
</table>
<p>记账时间为：2018.3.23 21:26:15</p>
<p>区块链在记账是会把账页信息（包含序号、记账时间、交易记录）作为原始信息进行Hash, 得到一个Hash值，如：787635ACD, 用函数表示为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(序号0、记账时间、交易记录) = 787635ACD</span><br></pre></td></tr></table></figure>
<p>账页信息和Hash值组合在一起就构成了第一个区块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比特币系统里约10分钟记一次账，即每个区块生成时间大概间隔10分钟</span><br></pre></td></tr></table></figure>
<p>在记第2个账页的时候，会把上一个块的Hash值和当前的账页信息一起作为原始信息进行Hash,即：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash(上一个Hash值、序号1、记账时间、交易记录) = 456635BCD</span><br></pre></td></tr></table></figure>
<p>这样第2个区块不仅包含了本账页信息，还间接的包含了第一个区块的信息。依次按照此方法继续记账，则最新的区块总是间接包含了所有之前的账页信息。</p>
<p>所有这些区块组合起来就形成了区块链，这样的区块链就构成了一个便于验证（只要验证最后一个区块的Hash值就相当于验证了整个账本），不可更改（任何一个交易信息的更改，会让所有之后的区块的Hash值发生变化，这样在验证时就无法通过）的总账本。</p>
<blockquote>
<p>并不是很详细的介绍，我觉得详情可以去看《区块链与新经济》——高航等编著这周暂且总结到这里，下周继续，大创是一场长跑，切记前期冲刺而疲惫。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/关于搜索的几个小算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/关于搜索的几个小算法/" itemprop="url">关于搜索的几个小算法（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-22T12:24:31+08:00">
                2018-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>首先这里先介绍一下为什么要总结一下搜索的算法，因为笔者最近要开始备战数学建模，队长要求我需要具备一些关于数据结构的遍历和二分等算法，并且要具备一些智能优化算法，如遗传算法，蚁群算法，模拟退火算法等，压力很大，这篇文章必须要在这个礼拜赶出来，这里的文风可能比较沉闷。</p>
</blockquote>
<h1 id="关于搜索的几个小算法"><a href="#关于搜索的几个小算法" class="headerlink" title="关于搜索的几个小算法"></a>关于搜索的几个小算法</h1><p>问题描述：关于搜索的算法主要是为了以后进行图的操作。</p>
<h2 id="不撞南墙不回头——深度优先搜索"><a href="#不撞南墙不回头——深度优先搜索" class="headerlink" title="不撞南墙不回头——深度优先搜索"></a>不撞南墙不回头——深度优先搜索</h2><h3 id="深度优先搜索的思想"><a href="#深度优先搜索的思想" class="headerlink" title="深度优先搜索的思想"></a>深度优先搜索的思想</h3><p>深度优先搜索使用的策略就像是名字所隐含的：只要有可能就尽量在图中“深入”。深度优先搜索总是对最近才发现的结点v的出发边进行探索，直到该结点的所有出发边都被发现为止。一旦结点v的所有出发边都被发现，搜索则“回溯”到v的前驱点（v是经过该点才被搜索到的），来搜索该前驱结点的出发边。这个过程一直持续到从源结点可以达到的所有节点都被发现为止。如果还存在尚未发现的结点，则深度优先搜索将从这些未被发现的结点中任选一个作为新的源结点，并重复同样的搜索过程，直到图中的所有结点都被发现为止。</p>
<h3 id="深度优先搜索的算法图解"><a href="#深度优先搜索的算法图解" class="headerlink" title="深度优先搜索的算法图解"></a>深度优先搜索的算法图解</h3><p>下面我们来看一下深度优先的图例（详见算法导论P351），在这里，我们用白色代表未被发现的点，灰色代表被发现但是未被搜索到的点，黑色代表已经被搜索过的点。</p>
<p><img src="http://img.blog.csdn.net/20150930171311886?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171331983?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171514677?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20150930171542023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171558895?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171628598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20150930171642359?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171659268?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171716631?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20150930171732754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171747699?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="http://img.blog.csdn.net/20150930171800288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p><img src="http://img.blog.csdn.net/20150930171821249?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>深度优先的运行过程如下：</p>
<p>(1). 第一个图里，我们可以看到所有结点都是白色，代表还未被发现</p>
<p>(2). 第二个图里，我们注意到1号结点的位置变成了灰色，但是其他的还是白色，一号结点指向2号结点</p>
<p>(3). 不出意外，第三个图里二号结点已经被发现了，以此类推，五号，四号结点</p>
<p>(4). 到四号结点的时候，我们发现四号结点并没有能继续向别处指向的箭头了，于是，我们把四号结点涂黑，表示搜索完毕，开始进行回溯到五号结点，依次执行的顺序分别是五号，二号，一号结点被涂黑。</p>
<p>(5). 一号结点已经被涂黑，但是图里还有其他的结点怎么半？我们另行找一个新的结点作为根结点，这里我们找到了三号结点。</p>
<p>(6). 三号结点想要指向五号结点（已经被搜索到标记成黑色的结点表示并不稀罕慢悠悠的三号结点，于是拒绝了他的搜索），三号结点只能指向六号结点。</p>
<p>(7). 六号结点也想继续向下指，但是他向下的箭头就是自己呀，自己指向已经被发现的自己，那么自己也被涂黑啦～于是开始回溯到3号点，发现他并没有下一个分支，这时候我们把三号点涂黑，搜索也就完毕啦～</p>
<h3 id="深度优先搜索的代码实现"><a href="#深度优先搜索的代码实现" class="headerlink" title="深度优先搜索的代码实现"></a>深度优先搜索的代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//深度优先的代码，可以有两种实现方式——递归和非递归，但是笔者这里认为递归更能把深度优先的概念描述清楚</span><br><span class="line">class DFS_shixian&#123;</span><br><span class="line">    enum Colour&#123;</span><br><span class="line">        whilte, gray, black;</span><br><span class="line">    &#125;</span><br><span class="line">    class Node&#123;</span><br><span class="line">       	List&lt;Node&gt; adjNodeList;</span><br><span class="line">       	Colour colur;</span><br><span class="line">    &#125;</span><br><span class="line">    //DFS核心实现代码</span><br><span class="line">    void DFS(Node u)&#123;</span><br><span class="line">        u.colour = Colour.gray;</span><br><span class="line">        for(Node v : u.adjNodeList)&#123;  //这里是java用语，大概格式是for(元素类型t 元素变量x : 遍历										  //对象obj)</span><br><span class="line">            if (v.colour = Colour.white)&#123;</span><br><span class="line">                v.colour = Colour.gray;</span><br><span class="line">                DFS(v); //进行更深一步的搜索，</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    u.colour = Colour.black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于以上的代码，大家可能觉得有一些抽象，我现在看起来也还是一脸懵逼，觉得还是用C语言代码实现比较好懂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;cstring&gt;</span><br><span class="line"># include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string str[300];</span><br><span class="line">int vis[300], i; //标记数组，在一个路径中，防止出现循环查找出现死循环</span><br><span class="line">int flag = 0; //用于判断是否已经查找到了，相当于是否结点变黑</span><br><span class="line"></span><br><span class="line">void DFS(string use)&#123;</span><br><span class="line">    char last = use[use.length() - 1];</span><br><span class="line">    if (flag == 1) //flag为1则表明已经被找到了，那么我们就退出，避免不必要的操作</span><br><span class="line">    	return ;</span><br><span class="line">    for (int k = 0; k &lt; i; k++)&#123; //开始进行遍历循环，</span><br><span class="line">        if (vis[k]==0 &amp;&amp; str[k][0]==last)&#123; //如果未被遍历，并且其开始结点和父结点相同，那我们开始遍历搜索</span><br><span class="line">            vis[k] = 1; //时刻把搜索到的点进行标记</span><br><span class="line">            if(str[k][str[k].length() - 1] == &apos;m&apos;)&#123; //若搜索到满足条件，我们这里就把flag设置为1，并且退出</span><br><span class="line">                flag = 1;</span><br><span class="line">                return ;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            	dfs(str[k]); //没有则不断递归直到搜索到</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	while(cin &gt;&gt; str[i])&#123;</span><br><span class="line">        if(str[i] == &quot;0&quot;)&#123;</span><br><span class="line">            memset(vis, 0, sizeof(vis) );</span><br><span class="line">            flag = 0;</span><br><span class="line">            for (int j = 0; j &lt; i; j++)&#123;</span><br><span class="line">                if(str[j][0] == &apos;b&apos;)&#123;</span><br><span class="line">                    vis[j] = 1;</span><br><span class="line">                    dfs(str[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i = 0;</span><br><span class="line">            if(flag == 1)</span><br><span class="line">            	cout &lt;&lt; &quot;Yes.&quot; &lt;&lt; endl;</span><br><span class="line">            else </span><br><span class="line">            	cout &lt;&lt; &quot;NO.&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        	i++;</span><br><span class="line">	&#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦，代码到此结束，深度优先搜索笔者当时才大一上学期，完全不懂递归的概念，而且学长给我讲的时候很快很快，脸上有着把自己会的东西交出去的一脸满足感，当时的我真的是一脸懵逼，就是现在让我手写一份深度优先搜索的代码的话，我可能还是会出错，不管怎么说，暂且先这样，我们继续看下一个搜索。</p>
<hr>
<h2 id="一层一层推进——广度优先搜索"><a href="#一层一层推进——广度优先搜索" class="headerlink" title="一层一层推进——广度优先搜索"></a>一层一层推进——广度优先搜索</h2><blockquote>
<p>坦白而言，广度优先搜索并没有深度优先搜索这么难理解，个人感觉广度优先搜索是最简单的搜索了，因为在后期学习图算法的时候，感觉他们有或多或少的参考了广度优先搜索的原型，而且我觉得用二叉树的广度优先遍历会比较简单一点。</p>
</blockquote>
<h3 id="广度优先搜索的思想"><a href="#广度优先搜索的思想" class="headerlink" title="广度优先搜索的思想"></a>广度优先搜索的思想</h3><p>给定一个图G=（V， E）和一个可以识别的源结点s，广度优先搜索对图G中的边进行系统性的探索来发现可以从源结点s到达的所有结点。该算法能计算从源结点s到每个可到达的结点的距离（最少的边数），同时生成一棵“广度优先搜索树”。该树以园街店s为根结点，包含所有可以从s到达的结点。对于每个从源结点s可以到达的结点v，在广度优先搜索树里从结点s到结点v的简单路径所对应的就是图G中从结点s到结点v的“最短路径”，这个以后估计也会记录。</p>
<h3 id="广度优先搜索的算法图解"><a href="#广度优先搜索的算法图解" class="headerlink" title="广度优先搜索的算法图解"></a>广度优先搜索的算法图解</h3><p><img src="http://img.blog.csdn.net/20150710161545756" alt="这里写图片描述"></p>
<p>和上面的深度搜索图解一样，在这里，我们也用白色代表未被发现的点，灰色代表被发现但是未被搜索到的点，黑色代表已经被搜索过的点。</p>
<p>图解步骤的话这里就不赘述了，大家看过上面的图解的话，这里应该并不是很费劲。我们还是直接看一下代码的实现。</p>
<h3 id="广度优先搜索的代码实现"><a href="#广度优先搜索的代码实现" class="headerlink" title="广度优先搜索的代码实现"></a>广度优先搜索的代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">bool BFS(Node&amp; Vs, Node&amp; Vd)&#123;  </span><br><span class="line">    queue&lt;Node&gt; Q;  </span><br><span class="line">    Node Vn, Vw;  </span><br><span class="line">    int i;  </span><br><span class="line">  </span><br><span class="line">    //初始状态将起点放进队列Q  </span><br><span class="line">    Q.push(Vs);  </span><br><span class="line">    hash(Vw) = true;//设置节点已经访问过了！  </span><br><span class="line">  </span><br><span class="line">    while (!Q.empty())&#123;//队列不为空，继续搜索！  </span><br><span class="line">        //取出队列的头Vn  </span><br><span class="line">        Vn = Q.front();  </span><br><span class="line">  </span><br><span class="line">        //从队列中移除  </span><br><span class="line">        Q.pop();  </span><br><span class="line">  </span><br><span class="line">        while(Vw = Vn通过某规则能够到达的节点)&#123;  </span><br><span class="line">            if (Vw == Vd)&#123;//找到终点了！  </span><br><span class="line">                //把路径记录，这里没给出解法  </span><br><span class="line">                return true;//返回  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            if (isValid(Vw) &amp;&amp; !visit[Vw])&#123;  </span><br><span class="line">                //Vw是一个合法的节点并且为白色节点  </span><br><span class="line">                Q.push(Vw);//加入队列Q  </span><br><span class="line">                hash(Vw) = true;//设置节点颜色  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return false;//无解  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们摘了一个网上的一个例子，上学五天之后又要军训，心累！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/关于字符串的匹配算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/关于字符串的匹配算法/" itemprop="url">关于字符串的匹配算法（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T14:50:51+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">Algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于字符串的匹配算法"><a href="#关于字符串的匹配算法" class="headerlink" title="关于字符串的匹配算法"></a>关于字符串的匹配算法</h1><blockquote>
<p>问题描述：给出了一块印有acaabc图案的布，如何知道aab的图案出现几次呢？这里涉及到了字符串的匹配问题，当我们遇到这样的问题该怎么解答呢？一起来看一下吧。</p>
</blockquote>
<h2 id="1-暴力破解法——BF算法"><a href="#1-暴力破解法——BF算法" class="headerlink" title="1.暴力破解法——BF算法"></a>1.暴力破解法——BF算法</h2><blockquote>
<p>法如其名，BF算法没有涉及什么重要的概念，我们假设有两个游标I，j分别指向文本串（T）和模式串（P）（文本串就是一整块大布，模式串就是需要找出的图案）</p>
<p>那么，当出现T[I]=P[j]的时候，则进行I++，j++。当出现T[I] != P[j]的时候（匹配失败啦～）此时，I回溯到本次开始匹配的位置，j=0。</p>
</blockquote>
<p>我们来看一看代码以便更容易懂BF算法的思路</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int BFsearch(char  * T, char * P)&#123;</span><br><span class="line">    int N, M;</span><br><span class="line">    N = strlen(T); //获取文本串的长度</span><br><span class="line">    M = strlen(P); //获取模式串的长度</span><br><span class="line">    </span><br><span class="line">    //文本串从0到N-M进行偏移，开始进行匹配</span><br><span class="line">    for(int s = 0; s &lt;= N-M; s++)&#123;</span><br><span class="line">    //模式串从0到M进行匹配</span><br><span class="line">        for (int i = 0; i &lt; M; i++)&#123;</span><br><span class="line">            if(P[i] != T[i+s] ) //如果在这里出现匹配失败，那么跳出当前的for循环，</span><br><span class="line">            					//执行s++语句，进行下一步的匹配</span><br><span class="line">                break;</span><br><span class="line">            if(i == M-1)&#123;        //当i = M-1时，就证明我们要的图案已经找到啦～</span><br><span class="line">                cout &lt;&lt; &quot;having matched&quot;;</span><br><span class="line">                return s;		//这里我们返回此时s的位置，便于下一步的操作，</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们在看图片演示一下，来栗子喽：<img src="http://img.blog.csdn.net/20170212231421875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ2NzA0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>(a). 字符串开始匹配，可以看到，我们的大布和需要识别的图案的第一个字母是一样的呢～那么很显然的，我们看到了T[0] = P[0]，那么我们开始进行下一步的匹配，开始执行i++，s=s+I此时I变为1，s也变为1，这时候布的图案变成了c而我们要找的是a图案，T[1] != P[1]，这时候就跳出我们的第二个for循环，执行s++语句，开始我们的b步骤。</p>
<p>(b). 啊哦～一上来就出现T[s] != P[0]了呢，没办法，我们直接跳出循环进行c步骤吧</p>
<p>(c). 这时候我们可以按照a步骤开始进行匹配，T[s] = P[0], 继续执行第二个for循环语句，I++，直到I达到了我们需要找到图案的长度大小，好啦，大功告成，可以暂且喝杯茶休息一下啦～如果小伙伴们还想看剩下的部分里还有没有这样的图案，继续使s自加，方法类似就好啦。</p>
<h3 id="BF算法的时间复杂度"><a href="#BF算法的时间复杂度" class="headerlink" title="BF算法的时间复杂度"></a>BF算法的时间复杂度</h3><p>从时间复杂度方面来分析， 我们走的计算次数是M（N-M），大概的时间复杂度是O（M*N），相对而言是一个平方的数字。</p>
<hr>
<h2 id="2-比较高档的算法——KMP算法"><a href="#2-比较高档的算法——KMP算法" class="headerlink" title="2.比较高档的算法——KMP算法"></a>2.比较高档的算法——KMP算法</h2><blockquote>
<p>算法背景：KMP算法是由Knuth，Morris和Pratt三位大牛设计的线形时间字符串匹配算法。我们这里还是用一大块布来较为形象的说明问题，有一块ababababababababababcdef的大布，我们需要找到一个abcd的图案，可以看到，大布上有好多ab连在一起却没有c，如果用BF算法的话，我们就要把前面的ab几乎都执行一遍，这对于少部分数据来说还比较快，但是对于超级超级多的数据来说显得过于繁琐，KMP算法提出了一个前缀和后缀的概念（我也不知道是谁提出来的，第一次接触前缀和后缀是在这里），接下来我们就看看传说中的KMP算法把！</p>
</blockquote>
<p>由于KMP算法难度较大，并且搜刮各路博客之后，发现并没有哪一个我可以明明白白，这里我也不敢保证各位看官可以看懂。</p>
<h3 id="KMP算法思想"><a href="#KMP算法思想" class="headerlink" title="KMP算法思想"></a>KMP算法思想</h3><p>KMP算法的思想是在一个大的字符串O里寻找一个小的f， 当匹配到位置I时两个字符串不相等，这时，我们将小的字符串f进行右移，我们知道，在BF算法里，每次移动的距离都是1，但BF算法并没有考虑到在前面我们已经比较了i-1个字符的事实，所以此算法的效率并不是很高。试想，如果我们提前对大的字符串T进行下预处理，并对其进行分析，找到一个下一步该右移几个单位的k值，分析一下位移前后的小字符串P有什么特点，我们可以得到这样的结论。</p>
<p>(a). A段字符串是f的一个前缀</p>
<p>(b). B段字符串是f的一个后缀</p>
<p>(c). A段字符串和B段字符串相等</p>
<p>所以，在右移k个单位后，我们可以继续比较第I个字符的    前提是我们前面的i-1个字符是已经匹配好了的，换句话说就是长度为i-k-1的前缀A和后缀B相同，我们就可以把f进行右移，达到继续匹配的目的。<img src="http://img.blog.csdn.net/20130924000026250" alt="img"></p>
<blockquote>
<p>KMP算法的核心是计算字符串f每一个位置的字符串前缀和后缀公共部分的最大长度（不包括字符串本身，否则最大长度始终是字符串本身）。获得f每一个位置的最大公共长度之后，就可以利用求出来的最大公共长度快速和字符串O进行比较，当出现不同字符时，我们就将f向右移动（以匹配长度 - 最大公共长度）位，接着比较下一个位置。</p>
</blockquote>
<h3 id="前缀和后缀的概念"><a href="#前缀和后缀的概念" class="headerlink" title="前缀和后缀的概念"></a>前缀和后缀的概念</h3><p>相信大家在看完上面的内容，对于前缀和后缀是什么还是一脸懵逼，我们在这里举一个栗子，例如当我们给出了一个字符串：abcd</p>
<p>那么他的前缀有                                                   他的后缀有</p>
<p>a                                                                              d</p>
<p>ab                                                                           cd</p>
<p>abc                                                                         bcd</p>
<p>当然不能包括自身喽， 所以就没有abcd的前缀和abcd的后缀啦</p>
<h3 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h3><p>了解了前缀后缀的概念，下面我们就开始进行求最大公共长度的大事啦～为了方便，我们引入了一个next数组来方便记录我们求得的遍历原字符串时求得的最大公共长度（这里我们要清楚的知道，next存放的数据下标是从0开始，还是从1开始）。</p>
<p>这里我们先来看一些例子：</p>
<ol>
<li>T=“abcdex”，我们引入一个变量j来表示模式串的位置</li>
</ol>
<p>(1). 当j=1时，next[1]=0;</p>
<p>(2). 当j=2时，j由1到j-1就只有字符“a”，属于其他情况，这里我们就可以知道next[2]=1;</p>
<p>(3). 当j=3时，j由1到j-1串是“ab”， 显然“a”和“b”是不相同的，属于其他情况，那么next[3]=1；</p>
<p>(4). 同理，我们知道模式串T的next[j]为011111.</p>
<p><img src="https://images0.cnblogs.com/blog2015/755265/201507/052047396071612.jpg" alt="img"></p>
<ol>
<li>T=“abcabx”</li>
</ol>
<p>(1). 当j=1时，next[1]=0;</p>
<p>(2). 当j=2时，同理next[2]=1;</p>
<p>(3). 当j=3时，同理next[3]=1;</p>
<p>(4). 当j=4时，同理next[4]=1;</p>
<p>(5). 当j=5时，这时候不能同理啦～我们来看一看这时候j从1到j-1的串串，“abca”，是不是发现啦这个串串的前缀和后缀的共同之处呢？没错就是“a”， 因此next[5]不能在等于1啦， 我们要给它的值进行加1操作，因此next[5]=2;</p>
<p>(6). 当j=6时，我们可以知道这时候的串串是“abcab”，这里的前缀“ab”和后缀“ab”是不是又是相等的呢？那么我们在进行加一操作，这时候next[6]=3;</p>
<p>这里我们就可以推测一下next数组的值和匹配到相等字符的个数的关系啦～嗯～～一个相等的时候next是2，两个是3，那么n个匹配到相等的字符next数组的值就是n+1啦。</p>
<p><img src="https://images0.cnblogs.com/blog2015/755265/201507/052047452793380.jpg" alt="img"></p>
<blockquote>
<p>这里有一点点提示，在匹配next的时候，我们要知道，next数组的第一个是next[0]开始而不是next[1]哦～所以我们在匹配的时候最好错开一个位置看</p>
</blockquote>
<p>说了那么多，还是没有一行代码，下面我们还是看一看KMP算法的实现吧～</p>
<h3 id="KMP算法的代码实现"><a href="#KMP算法的代码实现" class="headerlink" title="KMP算法的代码实现"></a>KMP算法的代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//计算并获取要匹配的串T的next数组</span><br><span class="line">void get_next(string T, int * next)&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    i = 1;</span><br><span class="line">    j = 0;</span><br><span class="line">    next[1] = 0;</span><br><span class="line">    while (i &lt; T[0])&#123;  //这里的T[0]表示的是串的长度</span><br><span class="line">        if(j == 0 || T[i] == T[j])&#123; //T[i]表示后缀的单个字符</span><br><span class="line">            i++;					//T[j]表示前缀的单个字符</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">        	j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//KMP算法</span><br><span class="line">int KMP(string S, string T, int pos)&#123;</span><br><span class="line">    int i = pos;				//i用于主串s当前位置下标值，若pos不为1则从pos位置开始匹配</span><br><span class="line">    int j = 1;					//j用于子串T中当前位置下标值</span><br><span class="line">    int next[100]; 				//定义一个next数组</span><br><span class="line">    get_next(T, next);			//得到next数组</span><br><span class="line">    while(i&lt;=S[0] &amp;&amp; j&lt;=T[0])&#123;	//大致思路和BF算法相同，这里我们换一种格式写便于大家理解其中原理</span><br><span class="line">        if(j==0 || S[i]==T[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        	j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    if(j &gt; T[0])</span><br><span class="line">    	return i - T[0];</span><br><span class="line">    else</span><br><span class="line">    	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此我们KMP算法也说完啦，关于KMP算法的改进的话，我觉得大家有基础的话自己上网搜一搜博客就可以搞定啦～我们下一期再见</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Avril_Lavigne%27s_signature.svg/520px-Avril_Lavigne%27s_signature.svg.png"
                alt="Alex" />
            
              <p class="site-author-name" itemprop="name">Alex</p>
              <p class="site-description motion-element" itemprop="description">We are all live in the gutter, but some of us are looking at the star</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
